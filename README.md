<b align="center">
  <br>
  <pre>
    ___  _ _   ___ 
  / __|| | | | _ \
 | (__ |_  _||  _/
  \___|  |_| |_|  
  </pre>
</b>
<h1 align="center">
  <br>
  Containers for Pentesters
  <br>
</h1>

<h4 align="center">Run your favourite pentesting tools in containers as if they were native.</h4>
<p align="center"><img src="https://img.shields.io/badge/License-Apache_2.0-blue.svg?logo=none" alt="license" />&nbsp;<a href="https://github.com/TheArqsz/containers4pentesters/actions/workflows/verify-tools.yml" target="_blank"><img src="https://github.com/TheArqsz/containers4pentesters/actions/workflows/verify-tools.yml/badge.svg?branch=main" alt="Verify c4p tools" /></a></p>

<p align="center">
<a href="#get-started">Get started</a> | <a href="#usage">Usage</a> | <a href="#usage-examples">Usage Examples</a> | <a href="#why">Why?</a> | <a href="#how-does-it-work">How does it work?</a> | <a href="#roadmap">Roadmap</a> 
</p>

## Get started

1.  Clone this repository
```console
git clone https://github.com/TheArqsz/containers4pentesters
```

2. Run `c4p.sh`
```console
./c4p.sh 
```

> If you want to install specific tool, run:
```console
./c4p.sh --tool nmap
```

3. Open new shell and enjoy your newly installed tool
```
nmap --help
```

## Usage

```
Usage: ./c4p.sh -t tool...
Install common pentester tools in containers as if they were native

Optional arguments:
   -t, --tool             Tool to be installed (default: all)
   -f, --force            Force install tool
   -l, --list             List available tools
       --config           Specify c4p config file to be used as a source for the shell

       --log-level        Level of logging (0 to 4, default: 3)
       --log-file         File to send logs to
       --only-log-file    Send logs only to file

       --fail             Exit script on error
   -v, --verbose          Set verbose mode
```

## Usage Examples

- List all available tools
```console
./c4p.sh --list
```

- Install specific tool
```console
./c4p.sh --tool nmap
```

- Force reinstall of all tools
```console
./c4p.sh --force
```

- Force reinstall specific tool
```console
./c4p.sh --force --tool nmap
```

- Show debugging logs 
```console
./c4p.sh --tool nmap --log-level 4
```

- Send logs only to file
```console
./c4p.sh --tool nmap --log-level 4 --only-log-file
```

...and many more to come

## Requirements

- Linux
- Docker (or other containerization daemon compatible with OCI)

Nowadays, installation of Docker is really simple so there is no point at explaining it. Just install it accordingly to your distribution's manuals and follow instructions at [Get Started](#get-started).

## Why?

The most important question of all - `why`. Why? Because why not! I myself work as a penetration tester on various environments and ecosystems, switch from VM to VM and don't want to waste my time on installation of tools. As a container-geek I asked myself - why not containerize it? The purpose of this project is not to replace native tools that can be sometimes installed easier than this, but rather to make your live simpler when you are really bored and just want to have an environment ready to hack. 

## How does it work?

This project takes advantage of versatility of containers. When tool is installed, entry is created in config file (`~/.c4p_config` by default), e.g.:
```bash
gobuster() {
    /home/user/containers4pentesters/lib/run.sh gobuster "$@"
}
```
This configuration file is sourced in `~/.bashrc` so functions can be accessed from the shell.
When new shell is spawned, `tool` function is available from within it: 
```console
$ gobuster --help

Usage:
  gobuster [command]
...
```

So basically, `tool` method is just a wrapper for a [`run.sh`](lib/run.sh) script that controls containers. All of arguments are passed to a function so user can think, that this particular tool is installed natively in the system. 

Tools are stored in the `tools` directory - each tool in a seperate folder. There, two mandatory files are present:
- [`Dockerfile`](tools/template/Dockerfile)
- [`test.sh`](tools/template/test.sh)

Dockerfiles specify how the tools are built, and `test.sh` makes sure that given tool is correctly installed and works as intended. What is needed, is just an output of a known command and a pattern that is expected to be returned by this command - example for `sqlmap`:
```bash
command_output=$(bash $LIB_PATH/run.sh $CURRENT_TOOL --help)
pattern="Usage: python sqlmap.py"
```

This is passed to a global [test.sh](lib/test.sh) script that validates the arguments and verifies that output of a command is correct. As simple as that.  

## Roadmap

There a couple of ideas to be implemented, e.g.:
- integration with native `man pages`
- increased speed 
- whole host system accessible for a tool inside of the container
- Better logo than an ASCII text 

## License

Code released under the [Apache 2.0](LICENSE) license.